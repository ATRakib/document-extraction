from fastapi import APIRouter, Depends, HTTPException, status, Response

from fastapi.responses import HTMLResponse
from app.config.settings import get_settings
settings = get_settings()
from app.schemas.auth import LoginRequest, TokenResponse
from app.schemas.user import UserCreate, UserResponse
from app.services.user_service import UserService
from app.services.auth_service import AuthService
from app.config.database import get_db
from app.utils.security import get_current_user
from app.models.user import User
import pyodbc
from datetime import timedelta

router = APIRouter(prefix="/api/auth", tags=["Authentication"])

@router.post("/register", response_model=dict, status_code=status.HTTP_201_CREATED)
def register(user_data: UserCreate, conn: pyodbc.Connection = Depends(get_db)):
    user_service = UserService(conn)
    
    existing_user = user_service.get_user_by_username(user_data.Username)
    if existing_user:
        raise HTTPException(status_code=400, detail="Username already exists")
    
    user_id = user_service.create_user(user_data.Username, user_data.Email, user_data.Password)
    
    return {"message": "User created successfully", "user_id": user_id}

@router.post("/login", response_model=TokenResponse)
def login(login_data: LoginRequest, response: Response, conn: pyodbc.Connection = Depends(get_db)):
    user_service = UserService(conn)
    
    user = user_service.authenticate_user(login_data.Username, login_data.Password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password"
        )
    
    access_token_expires = timedelta(minutes=settings.JWT_ACCESS_TOKEN_EXPIRE_MINUTES )
    access_token = AuthService.create_access_token(
        data={"sub": user.Username, "user_id": user.Id},
        expires_delta=access_token_expires
    )
    
    response.set_cookie(
        key="access_token",
        value=f"Bearer {access_token}",
        httponly=True,
        max_age=1800,
        expires=1800,
        samesite="lax",
        secure=False
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@router.post("/logout")
def logout(response: Response, current_user: User = Depends(get_current_user)):
    response.delete_cookie(key="access_token")
    return {"message": "Logged out successfully"}

@router.get("/me", response_model=UserResponse)
def get_current_user_info(current_user: User = Depends(get_current_user)):
    return UserResponse(
        Id=current_user.Id,
        Username=current_user.Username,
        Email=current_user.Email,
        IsActive=current_user.IsActive
    )from fastapi import APIRouter, Depends, HTTPException, status
from typing import List
from app.schemas.product import SupplierCreate, SupplierResponse, ProductInsertRequest
from app.services.product_service import ProductService
from app.config.database import get_db
from app.utils.security import check_permission
import pyodbc

router = APIRouter(prefix="/api/products", tags=["Products"])

# ==================== SUPPLIER CRUD ====================

@router.post("/suppliers", response_model=dict, status_code=status.HTTP_201_CREATED)
def create_supplier(
    supplier_data: SupplierCreate,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Create"))
):
    product_service = ProductService(conn)
    supplier_id = product_service.create_supplier(supplier_data.dict())
    return {"message": "Supplier created successfully", "supplier_id": supplier_id}

@router.get("/suppliers", response_model=List[SupplierResponse])
def get_all_suppliers(
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Read"))
):
    product_service = ProductService(conn)
    suppliers = product_service.get_all_suppliers()
    return [SupplierResponse(**s.dict()) for s in suppliers]

@router.get("/suppliers/{supplier_id}", response_model=SupplierResponse)
def get_supplier_by_id(
    supplier_id: int,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Read"))
):
    product_service = ProductService(conn)
    supplier = product_service.get_supplier_by_id(supplier_id)
    
    if not supplier:
        raise HTTPException(status_code=404, detail="Supplier not found")
    
    return SupplierResponse(**supplier.dict())

@router.put("/suppliers/{supplier_id}", response_model=dict)
def update_supplier(
    supplier_id: int,
    supplier_data: SupplierCreate,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Update"))
):
    product_service = ProductService(conn)
    
    existing_supplier = product_service.get_supplier_by_id(supplier_id)
    if not existing_supplier:
        raise HTTPException(status_code=404, detail="Supplier not found")
    
    product_service.update_supplier(supplier_id, supplier_data.dict())
    return {"message": "Supplier updated successfully", "supplier_id": supplier_id}

@router.delete("/suppliers/{supplier_id}", response_model=dict)
def delete_supplier(
    supplier_id: int,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Delete"))
):
    product_service = ProductService(conn)
    
    existing_supplier = product_service.get_supplier_by_id(supplier_id)
    if not existing_supplier:
        raise HTTPException(status_code=404, detail="Supplier not found")
    
    product_service.delete_supplier(supplier_id)
    return {"message": "Supplier deleted successfully", "supplier_id": supplier_id}

# ==================== PRODUCT CRUD ====================

@router.post("/insert", response_model=dict, status_code=status.HTTP_201_CREATED)
def insert_product(
    request: ProductInsertRequest,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Create"))
):
    product_service = ProductService(conn)
    result = product_service.insert_product_with_specifications(
        request.master,
        request.specifications
    )
    return {"message": "Product inserted successfully", "data": result}

@router.get("/", response_model=List[dict])
def get_all_products(
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Read"))
):
    product_service = ProductService(conn)
    products = product_service.get_all_products()
    return [p.dict() for p in products]

@router.get("/{product_id}", response_model=dict)
def get_product_by_id(
    product_id: int,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Read"))
):
    product_service = ProductService(conn)
    product = product_service.get_product_by_id(product_id)
    
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")
    
    specifications = product_service.get_specifications_by_product_id(product_id)
    
    return {
        "product": product.dict(),
        "specifications": [s.dict() for s in specifications]
    }

@router.put("/{product_id}", response_model=dict)
def update_product(
    product_id: int,
    request: ProductInsertRequest,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Update"))
):
    product_service = ProductService(conn)
    
    existing_product = product_service.get_product_by_id(product_id)
    if not existing_product:
        raise HTTPException(status_code=404, detail="Product not found")
    
    result = product_service.update_product_with_specifications(
        product_id,
        request.master,
        request.specifications
    )
    return {"message": "Product updated successfully", "data": result}

@router.delete("/{product_id}", response_model=dict)
def delete_product(
    product_id: int,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Delete"))
):
    product_service = ProductService(conn)
    
    existing_product = product_service.get_product_by_id(product_id)
    if not existing_product:
        raise HTTPException(status_code=404, detail="Product not found")
    
    product_service.delete_product(product_id)
    return {"message": "Product deleted successfully", "product_id": product_id}from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, Form, Body
from typing import List, Dict, Any
from app.services.extraction_service import ExtractionService
from app.services.product_service import ProductService
from app.repositories.product_repository import ProductRepository
from app.config.database import get_db
from app.utils.security import check_permission
import pyodbc

router = APIRouter(prefix="/api/upload", tags=["Document Upload & Extraction"])

@router.post("/extract/preview")
async def extract_preview(
    file: UploadFile = File(...),
    keywords: str = Form(""),
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Read"))
):
    extraction_service = ExtractionService()
    product_repo = ProductRepository(conn)
    
    try:
        result = await extraction_service.process_document(file, keywords)
        
        # Check if file already processed
        is_duplicate = product_repo.check_file_processed(result["file_hash"])
        
        return {
            "message": "Preview generated successfully",
            "product_data_list": result["product_data_list"],
            "is_duplicate": is_duplicate,
            "file_hash": result["file_hash"],
            "file_name": result["file_name"]
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Extraction failed: {str(e)}")

@router.post("/save/extracted")
async def save_extracted_products(
    data: Dict[str, Any] = Body(...),
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Create"))
):
    product_service = ProductService(conn)
    product_repo = ProductRepository(conn)
    
    product_data_list = data.get("product_data_list", [])
    file_hash = data.get("file_hash", "")
    file_name = data.get("file_name", "")
    
    try:
        # Check if file already processed
        if product_repo.check_file_processed(file_hash):
            raise HTTPException(
                status_code=400, 
                detail=f"Duplicate file detected! '{file_name}' has already been processed."
            )
        
        inserted_products = []
        for product_data in product_data_list:
            insert_result = product_service.insert_product_with_specifications(
                product_data["master"],
                product_data["specifications"]
            )
            inserted_products.append(insert_result)
        
        # Mark file as processed
        product_repo.mark_file_as_processed(file_name, file_hash)
        
        return {
            "message": f"{len(inserted_products)} product(s) saved successfully",
            "products": inserted_products
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Save failed: {str(e)}")

from fastapi import APIRouter, Depends, HTTPException, status
from typing import List
from app.schemas.user import (
    UserResponse, RoleCreate, RoleResponse, 
    PermissionCreate, PermissionResponse,
    AssignRoleRequest, AssignPermissionRequest
)
from app.services.user_service import UserService
from app.config.database import get_db
from app.utils.security import check_permission
import pyodbc

router = APIRouter(prefix="/api/users", tags=["User Management"])

@router.get("/", response_model=List[UserResponse])
def get_all_users(
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Read"))
):
    user_service = UserService(conn)
    users = user_service.get_all_users()
    return [UserResponse(Id=u.Id, Username=u.Username, Email=u.Email, IsActive=u.IsActive) for u in users]

@router.post("/roles", response_model=dict, status_code=status.HTTP_201_CREATED)
def create_role(
    role_data: RoleCreate,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Create"))
):
    user_service = UserService(conn)
    role_id = user_service.create_role(role_data.RoleName, role_data.Description)
    return {"message": "Role created successfully", "role_id": role_id}

@router.get("/roles", response_model=List[RoleResponse])
def get_all_roles(
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Read"))
):
    user_service = UserService(conn)
    roles = user_service.get_all_roles()
    return [RoleResponse(Id=r.Id, RoleName=r.RoleName, Description=r.Description) for r in roles]

@router.post("/permissions", response_model=dict, status_code=status.HTTP_201_CREATED)
def create_permission(
    permission_data: PermissionCreate,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Create"))
):
    user_service = UserService(conn)
    permission_id = user_service.create_permission(permission_data.PermissionName, permission_data.Description)
    return {"message": "Permission created successfully", "permission_id": permission_id}

@router.get("/permissions", response_model=List[PermissionResponse])
def get_all_permissions(
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Read"))
):
    user_service = UserService(conn)
    permissions = user_service.get_all_permissions()
    return [PermissionResponse(Id=p.Id, PermissionName=p.PermissionName, Description=p.Description) for p in permissions]

@router.post("/assign-role", response_model=dict)
def assign_role_to_user(
    request: AssignRoleRequest,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Create"))
):
    user_service = UserService(conn)
    user_service.assign_role_to_user(request.UserId, request.RoleId)
    return {"message": "Role assigned successfully"}

@router.post("/assign-permission", response_model=dict)
def assign_permission_to_role(
    request: AssignPermissionRequest,
    conn: pyodbc.Connection = Depends(get_db),
    current_user = Depends(check_permission("Create"))
):
    user_service = UserService(conn)
    user_service.assign_permission_to_role(request.RoleId, request.PermissionId)
    return {"message": "Permission assigned successfully"}from fastapi import APIRouter, Request, Depends, Response
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from app.utils.security import get_current_user_optional
from app.models.user import User
import os

router = APIRouter(tags=["Web UI"])
templates = Jinja2Templates(directory="templates")

@router.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

@router.get("/login", response_class=HTMLResponse)
async def login_page(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

@router.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request):
    return templates.TemplateResponse("dashboard.html", {"request": request})from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from app.services.auth_service import AuthService
from app.config.database import get_db_connection
from app.services.user_service import UserService

class AuthMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # Skip auth for public endpoints
        public_paths = ["/api/auth/register", "/api/auth/login", "/docs", "/openapi.json", "/redoc"]
        
        if request.url.path in public_paths or request.url.path == "/":
            return await call_next(request)
        
        # Get token from header
        auth_header = request.headers.get("Authorization")
        
        if not auth_header or not auth_header.startswith("Bearer "):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Missing or invalid authorization header"
            )
        
        token = auth_header.split(" ")[1]
        payload = AuthService.decode_access_token(token)
        
        if payload is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid or expired token"
            )
        
        # Add user info to request state
        request.state.user_id = payload.get("user_id")
        request.state.username = payload.get("sub")
        
        response = await call_next(request)
        return responsefrom pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = Nonefrom pydantic import BaseModel
from typing import Optional
from datetime import datetime
from decimal import Decimal

class Supplier(BaseModel):
    Id: Optional[int] = None
    Name: str
    Address1: Optional[str] = None
    Address2: Optional[str] = None
    Country: Optional[str] = None
    Phone: Optional[str] = None
    Email: Optional[str] = None
    Fax: Optional[str] = None
    CreatedAt: Optional[datetime] = None

class ProductMaster(BaseModel):
    Id: Optional[int] = None
    ModelName: str
    Description: Optional[str] = None
    CountryOfOrigin: Optional[str] = None
    SupplierId: Optional[int] = None
    ProductPrice: Optional[Decimal] = None
    Quotation: Optional[str] = None
    FileName: Optional[str] = None
    FileLocation: Optional[str] = None
    CreatedAt: Optional[datetime] = None

class ProductSpecification(BaseModel):
    Id: Optional[int] = None
    ProductId: int
    SpecificationName: Optional[str] = None
    Size: Optional[str] = None
    OtherTerms: Optional[str] = None
    ProductSpecificationPrice: Optional[Decimal] = None
    CreatedAt: Optional[datetime] = Nonefrom pydantic import BaseModel
from typing import Optional
from datetime import datetime

class User(BaseModel):
    Id: Optional[int] = None
    Username: str
    Email: str
    HashedPassword: str
    IsActive: bool = True
    CreatedAt: Optional[datetime] = None

class Role(BaseModel):
    Id: Optional[int] = None
    RoleName: str
    Description: Optional[str] = None
    CreatedAt: Optional[datetime] = None

class Permission(BaseModel):
    Id: Optional[int] = None
    PermissionName: str
    Description: Optional[str] = None
    CreatedAt: Optional[datetime] = Noneimport pyodbc
from typing import List, Optional
from app.models.user import Role, Permission

class AuthRepository:
    def __init__(self, conn: pyodbc.Connection):
        self.conn = conn

    def create_role(self, role: Role) -> int:
        cursor = self.conn.cursor()
        cursor.execute(
            "INSERT INTO Roles (RoleName, Description) OUTPUT INSERTED.Id VALUES (?, ?)",
            role.RoleName, role.Description
        )
        role_id = cursor.fetchone()[0]
        self.conn.commit()
        return role_id

    def get_all_roles(self) -> List[Role]:
        cursor = self.conn.cursor()
        cursor.execute("SELECT Id, RoleName, Description, CreatedAt FROM Roles")
        rows = cursor.fetchall()
        return [Role(Id=row[0], RoleName=row[1], Description=row[2], CreatedAt=row[3]) for row in rows]

    def create_permission(self, permission: Permission) -> int:
        cursor = self.conn.cursor()
        cursor.execute(
            "INSERT INTO Permissions (PermissionName, Description) OUTPUT INSERTED.Id VALUES (?, ?)",
            permission.PermissionName, permission.Description
        )
        permission_id = cursor.fetchone()[0]
        self.conn.commit()
        return permission_id

    def get_all_permissions(self) -> List[Permission]:
        cursor = self.conn.cursor()
        cursor.execute("SELECT Id, PermissionName, Description, CreatedAt FROM Permissions")
        rows = cursor.fetchall()
        return [Permission(Id=row[0], PermissionName=row[1], Description=row[2], CreatedAt=row[3]) for row in rows]

    def assign_role_to_user(self, user_id: int, role_id: int):
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO UserRoles (UserId, RoleId) VALUES (?, ?)", user_id, role_id)
        self.conn.commit()

    def assign_permission_to_role(self, role_id: int, permission_id: int):
        cursor = self.conn.cursor()
        cursor.execute("INSERT INTO RolePermissions (RoleId, PermissionId) VALUES (?, ?)", role_id, permission_id)
        self.conn.commit()

    def get_user_permissions(self, user_id: int) -> List[str]:
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT DISTINCT p.PermissionName
            FROM Permissions p
            INNER JOIN RolePermissions rp ON p.Id = rp.PermissionId
            INNER JOIN UserRoles ur ON rp.RoleId = ur.RoleId
            WHERE ur.UserId = ?
        """, user_id)
        rows = cursor.fetchall()
        return [row[0] for row in rows]

    def get_user_roles(self, user_id: int) -> List[str]:
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT r.RoleName
            FROM Roles r
            INNER JOIN UserRoles ur ON r.Id = ur.RoleId
            WHERE ur.UserId = ?
        """, user_id)
        rows = cursor.fetchall()
        return [row[0] for row in rows]import pyodbc
import hashlib
from typing import Optional, List
from app.models.product import ProductMaster, ProductSpecification

class ProductRepository:
    def __init__(self, conn: pyodbc.Connection):
        self.conn = conn

    def check_file_processed(self, file_hash: str) -> bool:
        cursor = self.conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM ProcessedFiles WHERE FileHash = ?", file_hash)
        count = cursor.fetchone()[0]
        return count > 0

    def mark_file_as_processed(self, file_name: str, file_hash: str):
        cursor = self.conn.cursor()
        cursor.execute(
            "INSERT INTO ProcessedFiles (FileName, FileHash) VALUES (?, ?)",
            file_name, file_hash
        )
        self.conn.commit()

    def create_product_master(self, product: ProductMaster) -> int:
        cursor = self.conn.cursor()
        cursor.execute(
            """INSERT INTO ProductMaster (ModelName, Description, CountryOfOrigin, SupplierId, ProductPrice, Quotation, FileName, FileLocation) 
               OUTPUT INSERTED.Id VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
            product.ModelName, product.Description, product.CountryOfOrigin, 
            product.SupplierId, product.ProductPrice, product.Quotation, product.FileName, product.FileLocation
        )
        product_id = cursor.fetchone()[0]
        self.conn.commit()
        return product_id

    def create_product_specification(self, spec: ProductSpecification) -> int:
        cursor = self.conn.cursor()
        cursor.execute(
            """INSERT INTO ProductSpecification (ProductId, SpecificationName, Size, OtherTerms, ProductSpecificationPrice) 
               OUTPUT INSERTED.Id VALUES (?, ?, ?, ?, ?)""",
            spec.ProductId, spec.SpecificationName, spec.Size, 
            spec.OtherTerms, spec.ProductSpecificationPrice
        )
        spec_id = cursor.fetchone()[0]
        self.conn.commit()
        return spec_id

    def get_product_by_id(self, product_id: int) -> Optional[ProductMaster]:
        cursor = self.conn.cursor()
        cursor.execute(
            "SELECT Id, ModelName, Description, CountryOfOrigin, SupplierId, ProductPrice, Quotation, FileName, FileLocation, CreatedAt FROM ProductMaster WHERE Id = ?",
            product_id
        )
        row = cursor.fetchone()
        if row:
            return ProductMaster(Id=row[0], ModelName=row[1], Description=row[2], 
                               CountryOfOrigin=row[3], SupplierId=row[4], ProductPrice=row[5], 
                               Quotation=row[6], FileName=row[7], FileLocation=row[8], CreatedAt=row[9])
        return None

    def get_all_products(self) -> List[ProductMaster]:
        cursor = self.conn.cursor()
        cursor.execute("SELECT Id, ModelName, Description, CountryOfOrigin, SupplierId, ProductPrice, Quotation, FileName, FileLocation, CreatedAt FROM ProductMaster")
        rows = cursor.fetchall()
        return [ProductMaster(Id=row[0], ModelName=row[1], Description=row[2], 
                            CountryOfOrigin=row[3], SupplierId=row[4], ProductPrice=row[5],
                            Quotation=row[6], FileName=row[7], FileLocation=row[8], CreatedAt=row[9]) for row in rows]

    def get_specifications_by_product_id(self, product_id: int) -> List[ProductSpecification]:
        cursor = self.conn.cursor()
        cursor.execute(
            "SELECT Id, ProductId, SpecificationName, Size, OtherTerms, ProductSpecificationPrice, CreatedAt FROM ProductSpecification WHERE ProductId = ?",
            product_id
        )
        rows = cursor.fetchall()
        return [ProductSpecification(Id=row[0], ProductId=row[1], SpecificationName=row[2], 
                                   Size=row[3], OtherTerms=row[4], ProductSpecificationPrice=row[5], CreatedAt=row[6]) for row in rows]

    def update_product_master(self, product_id: int, product: ProductMaster):
        cursor = self.conn.cursor()
        cursor.execute(
            """UPDATE ProductMaster SET ModelName = ?, Description = ?, CountryOfOrigin = ?, 
               SupplierId = ?, ProductPrice = ?, Quotation = ?, FileName = ?, FileLocation = ? WHERE Id = ?""",
            product.ModelName, product.Description, product.CountryOfOrigin, 
            product.SupplierId, product.ProductPrice, product.Quotation, product.FileName, product.FileLocation, product_id
        )
        self.conn.commit()

    def delete_product(self, product_id: int):
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM ProductMaster WHERE Id = ?", product_id)
        self.conn.commit()

    def delete_specifications_by_product_id(self, product_id: int):
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM ProductSpecification WHERE ProductId = ?", product_id)
        self.conn.commit()import pyodbc
from typing import Optional, List
from app.models.product import Supplier

class SupplierRepository:
    def __init__(self, conn: pyodbc.Connection):
        self.conn = conn

    def create_supplier(self, supplier: Supplier) -> int:
        cursor = self.conn.cursor()
        cursor.execute(
            """INSERT INTO Supplier (Name, Address1, Address2, Country, Phone, Email, Fax) 
               OUTPUT INSERTED.Id VALUES (?, ?, ?, ?, ?, ?, ?)""",
            supplier.Name, supplier.Address1, supplier.Address2, 
            supplier.Country, supplier.Phone, supplier.Email, supplier.Fax
        )
        supplier_id = cursor.fetchone()[0]
        self.conn.commit()
        return supplier_id

    def get_supplier_by_id(self, supplier_id: int) -> Optional[Supplier]:
        cursor = self.conn.cursor()
        cursor.execute(
            "SELECT Id, Name, Address1, Address2, Country, Phone, Email, Fax, CreatedAt FROM Supplier WHERE Id = ?",
            supplier_id
        )
        row = cursor.fetchone()
        if row:
            return Supplier(Id=row[0], Name=row[1], Address1=row[2], Address2=row[3], 
                          Country=row[4], Phone=row[5], Email=row[6], Fax=row[7], CreatedAt=row[8])
        return None

    def get_supplier_by_name(self, name: str) -> Optional[Supplier]:
        cursor = self.conn.cursor()
        cursor.execute(
            "SELECT Id, Name, Address1, Address2, Country, Phone, Email, Fax, CreatedAt FROM Supplier WHERE Name = ?",
            name
        )
        row = cursor.fetchone()
        if row:
            return Supplier(Id=row[0], Name=row[1], Address1=row[2], Address2=row[3], 
                          Country=row[4], Phone=row[5], Email=row[6], Fax=row[7], CreatedAt=row[8])
        return None

    def get_all_suppliers(self) -> List[Supplier]:
        cursor = self.conn.cursor()
        cursor.execute("SELECT Id, Name, Address1, Address2, Country, Phone, Email, Fax, CreatedAt FROM Supplier")
        rows = cursor.fetchall()
        return [Supplier(Id=row[0], Name=row[1], Address1=row[2], Address2=row[3], 
                        Country=row[4], Phone=row[5], Email=row[6], Fax=row[7], CreatedAt=row[8]) for row in rows]

    def update_supplier(self, supplier_id: int, supplier: Supplier):
        cursor = self.conn.cursor()
        cursor.execute(
            """UPDATE Supplier SET Name = ?, Address1 = ?, Address2 = ?, Country = ?, 
               Phone = ?, Email = ?, Fax = ? WHERE Id = ?""",
            supplier.Name, supplier.Address1, supplier.Address2, 
            supplier.Country, supplier.Phone, supplier.Email, supplier.Fax, supplier_id
        )
        self.conn.commit()

    def delete_supplier(self, supplier_id: int):
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM Supplier WHERE Id = ?", supplier_id)
        self.conn.commit()import pyodbc
from typing import Optional, List
from app.models.user import User, Role, Permission

class UserRepository:
    def __init__(self, conn: pyodbc.Connection):
        self.conn = conn

    def create_user(self, user: User) -> int:
        cursor = self.conn.cursor()
        cursor.execute(
            "INSERT INTO Users (Username, Email, HashedPassword, IsActive) OUTPUT INSERTED.Id VALUES (?, ?, ?, ?)",
            user.Username, user.Email, user.HashedPassword, user.IsActive
        )
        user_id = cursor.fetchone()[0]
        self.conn.commit()
        return user_id

    def get_user_by_username(self, username: str) -> Optional[User]:
        cursor = self.conn.cursor()
        cursor.execute("SELECT Id, Username, Email, HashedPassword, IsActive, CreatedAt FROM Users WHERE Username = ?", username)
        row = cursor.fetchone()
        if row:
            return User(Id=row[0], Username=row[1], Email=row[2], HashedPassword=row[3], IsActive=row[4], CreatedAt=row[5])
        return None

    def get_user_by_id(self, user_id: int) -> Optional[User]:
        cursor = self.conn.cursor()
        cursor.execute("SELECT Id, Username, Email, HashedPassword, IsActive, CreatedAt FROM Users WHERE Id = ?", user_id)
        row = cursor.fetchone()
        if row:
            return User(Id=row[0], Username=row[1], Email=row[2], HashedPassword=row[3], IsActive=row[4], CreatedAt=row[5])
        return None

    def get_all_users(self) -> List[User]:
        cursor = self.conn.cursor()
        cursor.execute("SELECT Id, Username, Email, HashedPassword, IsActive, CreatedAt FROM Users")
        rows = cursor.fetchall()
        return [User(Id=row[0], Username=row[1], Email=row[2], HashedPassword=row[3], IsActive=row[4], CreatedAt=row[5]) for row in rows]from pydantic import BaseModel

class LoginRequest(BaseModel):
    Username: str
    Password: str

class TokenResponse(BaseModel):
    access_token: str
    token_type: strfrom pydantic import BaseModel
from typing import Optional, List
from decimal import Decimal

class SupplierCreate(BaseModel):
    Name: str
    Address1: Optional[str] = None
    Address2: Optional[str] = None
    Country: Optional[str] = None
    Phone: Optional[str] = None
    Email: Optional[str] = None
    Fax: Optional[str] = None

class SupplierResponse(BaseModel):
    Id: int
    Name: str
    Address1: Optional[str] = None
    Address2: Optional[str] = None
    Country: Optional[str] = None
    Phone: Optional[str] = None
    Email: Optional[str] = None
    Fax: Optional[str] = None

class ProductMasterCreate(BaseModel):
    ModelName: str
    Description: Optional[str] = None
    CountryOfOrigin: Optional[str] = None
    SupplierId: Optional[int] = None
    ProductPrice: Optional[Decimal] = None
    Quotation: Optional[str] = None
    FileName: Optional[str] = None
    FileLocation: Optional[str] = None

class ProductSpecificationCreate(BaseModel):
    SpecificationName: Optional[str] = None
    Size: Optional[str] = None
    OtherTerms: Optional[str] = None
    ProductSpecificationPrice: Optional[Decimal] = None

class ProductExtractResponse(BaseModel):
    master: dict
    specifications: List[dict]

class ProductInsertRequest(BaseModel):
    master: dict
    specifications: List[dict]from pydantic import BaseModel, EmailStr
from typing import Optional, List

class UserCreate(BaseModel):
    Username: str
    Email: EmailStr
    Password: str

class UserResponse(BaseModel):
    Id: int
    Username: str
    Email: str
    IsActive: bool

class RoleCreate(BaseModel):
    RoleName: str
    Description: Optional[str] = None

class RoleResponse(BaseModel):
    Id: int
    RoleName: str
    Description: Optional[str] = None

class PermissionCreate(BaseModel):
    PermissionName: str
    Description: Optional[str] = None

class PermissionResponse(BaseModel):
    Id: int
    PermissionName: str
    Description: Optional[str] = None

class AssignRoleRequest(BaseModel):
    UserId: int
    RoleId: int

class AssignPermissionRequest(BaseModel):
    RoleId: int
    PermissionId: intfrom datetime import datetime, timedelta
from jose import JWTError, jwt
import bcrypt
from app.config.settings import get_settings
from app.models.user import User
from typing import Optional
import secrets

settings = get_settings()

class AuthService:
    active_sessions = {}
    
    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        return bcrypt.checkpw(plain_password.encode('utf-8'), hashed_password.encode('utf-8'))

    @staticmethod
    def get_password_hash(password: str) -> str:
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')

    @staticmethod
    def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=settings.JWT_ACCESS_TOKEN_EXPIRE_MINUTES)
        
        session_id = secrets.token_urlsafe(32)
        to_encode.update({"exp": expire, "session_id": session_id})
        
        encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM)
        
        AuthService.active_sessions[session_id] = {
            "username": data.get("sub"),
            "user_id": data.get("user_id"),
            "created_at": datetime.utcnow(),
            "expires_at": expire
        }
        
        return encoded_jwt

    @staticmethod
    def decode_access_token(token: str):
        try:
            payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])
            session_id = payload.get("session_id")
            
            if session_id not in AuthService.active_sessions:
                return None
            
            session = AuthService.active_sessions[session_id]
            if session["expires_at"] < datetime.utcnow():
                del AuthService.active_sessions[session_id]
                return None
            
            return payload
        except JWTError:
            return None

    @staticmethod
    def revoke_session(token: str):
        try:
            payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])
            session_id = payload.get("session_id")
            
            if session_id in AuthService.active_sessions:
                del AuthService.active_sessions[session_id]
                return True
        except:
            pass
        return False

    @staticmethod
    def cleanup_expired_sessions():
        current_time = datetime.utcnow()
        expired_sessions = [
            sid for sid, session in AuthService.active_sessions.items()
            if session["expires_at"] < current_time
        ]
        for sid in expired_sessions:
            del AuthService.active_sessions[sid]import os
import shutil
import hashlib
from fastapi import UploadFile
from app.utils.document_parser import DocumentParser
from app.services.llm_service import LLMService
from app.config.settings import get_settings

settings = get_settings()

class ExtractionService:
    def __init__(self):
        self.llm_service = LLMService()
        self.upload_dir = settings.UPLOAD_DIR
        self.pdf_dir = settings.PDF_DIR
        self.word_dir = settings.WORD_DIR
        self.excel_dir = settings.EXCEL_DIR
        
        os.makedirs(self.pdf_dir, exist_ok=True)
        os.makedirs(self.word_dir, exist_ok=True)
        os.makedirs(self.excel_dir, exist_ok=True)

    def calculate_file_hash(self, file_content: bytes) -> str:
        return hashlib.sha256(file_content).hexdigest()

    async def save_upload_file(self, upload_file: UploadFile) -> tuple:
        ext = os.path.splitext(upload_file.filename)[1].lower()
        
        if ext == '.pdf':
            target_dir = self.pdf_dir
        elif ext in ['.docx', '.doc']:
            target_dir = self.word_dir
        elif ext in ['.xlsx', '.xls']:
            target_dir = self.excel_dir
        else:
            target_dir = self.upload_dir
        
        file_path = os.path.join(target_dir, upload_file.filename)
        
        content = await upload_file.read()
        file_hash = self.calculate_file_hash(content)
        
        with open(file_path, "wb") as f:
            f.write(content)
        
        return file_path, upload_file.filename, file_path, file_hash

    def extract_text_from_file(self, file_path: str) -> str:
        return DocumentParser.extract_text(file_path)

    def extract_product_data_from_text(self, text: str, keywords: str = "") -> list:
        return self.llm_service.extract_product_data(text, keywords)

    async def process_document(self, file: UploadFile, keywords: str = "") -> dict:
        file_path, file_name, file_location, file_hash = await self.save_upload_file(file)
        
        extracted_text = self.extract_text_from_file(file_path)
        
        product_data_list = self.extract_product_data_from_text(extracted_text, keywords)
        
        for product_data in product_data_list:
            product_data['master']['FileName'] = file_name
            product_data['master']['FileLocation'] = file_location
        
        return {
            "extracted_text": extracted_text,
            "product_data_list": product_data_list,
            "file_hash": file_hash,
            "file_name": file_name
        }

# import os
# import shutil
# from fastapi import UploadFile
# from app.utils.document_parser import DocumentParser
# from app.services.llm_service import LLMService
# from app.config.settings import get_settings

# settings = get_settings()

# class ExtractionService:
#     def __init__(self):
#         self.llm_service = LLMService()
#         self.upload_dir = settings.UPLOAD_DIR
#         self.pdf_dir = settings.PDF_DIR
#         self.word_dir = settings.WORD_DIR
#         self.excel_dir = settings.EXCEL_DIR
        
#         os.makedirs(self.pdf_dir, exist_ok=True)
#         os.makedirs(self.word_dir, exist_ok=True)
#         os.makedirs(self.excel_dir, exist_ok=True)

#     async def save_upload_file(self, upload_file: UploadFile) -> tuple:
#         ext = os.path.splitext(upload_file.filename)[1].lower()
        
#         if ext == '.pdf':
#             target_dir = self.pdf_dir
#         elif ext in ['.docx', '.doc']:
#             target_dir = self.word_dir
#         elif ext in ['.xlsx', '.xls']:
#             target_dir = self.excel_dir
#         else:
#             target_dir = self.upload_dir
        
#         file_path = os.path.join(target_dir, upload_file.filename)
        
#         with open(file_path, "wb") as f:
#             content = await upload_file.read()
#             f.write(content)
        
#         return file_path, upload_file.filename, file_path

#     def extract_text_from_file(self, file_path: str) -> str:
#         return DocumentParser.extract_text(file_path)

#     def extract_product_data_from_text(self, text: str, keywords: str = "") -> list:
#         return self.llm_service.extract_product_data(text, keywords)

#     async def process_document(self, file: UploadFile, keywords: str = "") -> dict:
#         file_path, file_name, file_location = await self.save_upload_file(file)
        
#         extracted_text = self.extract_text_from_file(file_path)
        
#         product_data_list = self.extract_product_data_from_text(extracted_text, keywords)
        
#         for product_data in product_data_list:
#             product_data['master']['FileName'] = file_name
#             product_data['master']['FileLocation'] = file_location
        
#         return {
#             "extracted_text": extracted_text,
#             "product_data_list": product_data_list
#         }from groq import Groq
from app.config.settings import get_settings
import json

settings = get_settings()

class LLMService:
    def __init__(self):
        self.client = Groq(api_key=settings.GROQ_API_KEY)

    def extract_product_data(self, extracted_text: str, keywords: str = "") -> list:
        system_prompt = """You are an expert data extraction system. Extract product information from the provided text and return ONLY a valid JSON array of objects.

Extract the following structure for EACH product found in the text:
[
  {
    "master": {
      "ModelName": "string",
      "Description": "string",
      "CountryOfOrigin": "string",
      "SupplierName": "string",
      "ProductPrice": 0.0,
      "Quotation": "string"
    },
    "specifications": [
      {
        "SpecificationName": "string",
        "Size": "string",
        "OtherTerms": "string",
        "ProductSpecificationPrice": 0.0
      }
    ]
  }
]

Rules:
- Extract ALL products from the document
- Each product must have master and specifications
- SupplierName should be the supplier/manufacturer name found in the document
- Quotation should contain quotation number or reference if found
- If a field is not found, use null or empty string
- ProductPrice and ProductSpecificationPrice must be numbers (use 0.0 if not found)
- Multiple specifications should be in the specifications array
- Return ONLY the JSON array, no additional text
"""

        user_prompt = f"""Extract product information from this text:

{extracted_text}

Keywords to focus on: {keywords}

Return ONLY the JSON array of products."""

        try:
            chat_completion = self.client.chat.completions.create(
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                model="llama-3.3-70b-versatile",
                temperature=0.1,
                max_tokens=4000
            )
            
            response_text = chat_completion.choices[0].message.content.strip()
            
            if response_text.startswith("```json"):
                response_text = response_text[7:]
            if response_text.startswith("```"):
                response_text = response_text[3:]
            if response_text.endswith("```"):
                response_text = response_text[:-3]
            
            response_text = response_text.strip()
            
            extracted_data = json.loads(response_text)
            
            if not isinstance(extracted_data, list):
                extracted_data = [extracted_data]
            
            return extracted_data
            
        except Exception as e:
            raise Exception(f"LLM extraction failed: {str(e)}")import pyodbc
from app.repositories.product_repository import ProductRepository
from app.repositories.supplier_repository import SupplierRepository
from app.models.product import ProductMaster, ProductSpecification, Supplier
from typing import List, Optional, Dict

class ProductService:
    def __init__(self, conn: pyodbc.Connection):
        self.product_repo = ProductRepository(conn)
        self.supplier_repo = SupplierRepository(conn)

    def create_supplier(self, supplier_data: dict) -> int:
        supplier = Supplier(**supplier_data)
        return self.supplier_repo.create_supplier(supplier)

    def get_all_suppliers(self) -> List[Supplier]:
        return self.supplier_repo.get_all_suppliers()

    def get_supplier_by_id(self, supplier_id: int) -> Optional[Supplier]:
        return self.supplier_repo.get_supplier_by_id(supplier_id)

    def get_supplier_by_name(self, name: str) -> Optional[Supplier]:
        return self.supplier_repo.get_supplier_by_name(name)

    def update_supplier(self, supplier_id: int, supplier_data: dict):
        supplier = Supplier(Id=supplier_id, **supplier_data)
        self.supplier_repo.update_supplier(supplier_id, supplier)

    def delete_supplier(self, supplier_id: int):
        self.supplier_repo.delete_supplier(supplier_id)

    def insert_product_with_specifications(self, master_data: dict, specifications_data: List[dict]) -> Dict:
        supplier_name = master_data.get('SupplierName')
        if supplier_name:
            supplier = self.get_supplier_by_name(supplier_name)
            if supplier:
                master_data['SupplierId'] = supplier.Id
            else:
                master_data['SupplierId'] = None
            del master_data['SupplierName']
        
        product = ProductMaster(**master_data)
        product_id = self.product_repo.create_product_master(product)
        
        spec_ids = []
        for spec_data in specifications_data:
            spec_data['ProductId'] = product_id
            spec = ProductSpecification(**spec_data)
            spec_id = self.product_repo.create_product_specification(spec)
            spec_ids.append(spec_id)
        
        return {
            "product_id": product_id,
            "specification_ids": spec_ids
        }

    def get_product_by_id(self, product_id: int) -> Optional[ProductMaster]:
        return self.product_repo.get_product_by_id(product_id)

    def get_all_products(self) -> List[ProductMaster]:
        return self.product_repo.get_all_products()

    def get_specifications_by_product_id(self, product_id: int) -> List[ProductSpecification]:
        return self.product_repo.get_specifications_by_product_id(product_id)

    def update_product_with_specifications(self, product_id: int, master_data: dict, specifications_data: List[dict]) -> Dict:
        supplier_name = master_data.get('SupplierName')
        if supplier_name:
            supplier = self.get_supplier_by_name(supplier_name)
            if supplier:
                master_data['SupplierId'] = supplier.Id
            else:
                master_data['SupplierId'] = None
            del master_data['SupplierName']
        
        product = ProductMaster(Id=product_id, **master_data)
        self.product_repo.update_product_master(product_id, product)
        
        self.product_repo.delete_specifications_by_product_id(product_id)
        
        spec_ids = []
        for spec_data in specifications_data:
            spec_data['ProductId'] = product_id
            spec = ProductSpecification(**spec_data)
            spec_id = self.product_repo.create_product_specification(spec)
            spec_ids.append(spec_id)
        
        return {
            "product_id": product_id,
            "specification_ids": spec_ids
        }

    def delete_product(self, product_id: int):
        self.product_repo.delete_product(product_id)import pyodbc
from app.repositories.user_repository import UserRepository
from app.repositories.auth_repository import AuthRepository
from app.models.user import User, Role, Permission
from app.services.auth_service import AuthService
from typing import List, Optional

class UserService:
    def __init__(self, conn: pyodbc.Connection):
        self.user_repo = UserRepository(conn)
        self.auth_repo = AuthRepository(conn)

    def create_user(self, username: str, email: str, password: str) -> int:
        hashed_password = AuthService.get_password_hash(password)
        user = User(Username=username, Email=email, HashedPassword=hashed_password)
        return self.user_repo.create_user(user)

    def authenticate_user(self, username: str, password: str) -> Optional[User]:
        user = self.user_repo.get_user_by_username(username)
        if not user:
            return None
        if not AuthService.verify_password(password, user.HashedPassword):
            return None
        return user

    def get_user_by_username(self, username: str) -> Optional[User]:
        return self.user_repo.get_user_by_username(username)

    def get_user_by_id(self, user_id: int) -> Optional[User]:
        return self.user_repo.get_user_by_id(user_id)

    def get_all_users(self) -> List[User]:
        return self.user_repo.get_all_users()

    def create_role(self, role_name: str, description: str = None) -> int:
        role = Role(RoleName=role_name, Description=description)
        return self.auth_repo.create_role(role)

    def get_all_roles(self) -> List[Role]:
        return self.auth_repo.get_all_roles()

    def create_permission(self, permission_name: str, description: str = None) -> int:
        permission = Permission(PermissionName=permission_name, Description=description)
        return self.auth_repo.create_permission(permission)

    def get_all_permissions(self) -> List[Permission]:
        return self.auth_repo.get_all_permissions()

    def assign_role_to_user(self, user_id: int, role_id: int):
        self.auth_repo.assign_role_to_user(user_id, role_id)

    def assign_permission_to_role(self, role_id: int, permission_id: int):
        self.auth_repo.assign_permission_to_role(role_id, permission_id)

    def get_user_permissions(self, user_id: int) -> List[str]:
        return self.auth_repo.get_user_permissions(user_id)

    def get_user_roles(self, user_id: int) -> List[str]:
        return self.auth_repo.get_user_roles(user_id)from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from app.controllers import auth_controller, user_controller, product_controller, upload_controller, web_controller
from app.config.settings import get_settings
import os

settings = get_settings()

app = FastAPI(
    title="Document Extraction & RBAC System",
    description="FastAPI application with document extraction, LLM processing, and role-based access control",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

os.makedirs("uploads", exist_ok=True)
os.makedirs("uploads/pdf", exist_ok=True)
os.makedirs("uploads/word", exist_ok=True)
os.makedirs("uploads/excel", exist_ok=True)
os.makedirs("static", exist_ok=True)
os.makedirs("templates", exist_ok=True)

app.mount("/static", StaticFiles(directory="static"), name="static")

app.include_router(web_controller.router)
app.include_router(auth_controller.router)
app.include_router(user_controller.router)
app.include_router(product_controller.router)
app.include_router(upload_controller.router)

@app.get("/health")
def health_check():
    return {"status": "healthy"}

